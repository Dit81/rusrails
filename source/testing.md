Руководство по тестированию приложений на Rails
===============================================

Это руководство раскрывает встроенные механизмы, предлагаемые Rails для тестирования вашего приложения.

После его прочтения, вы узнаете:

* О терминологии тестирования Rails.
* Как писать юнит-, функциональные и объединенные тесты для вашего приложения.
* О других популярных подходах к тестированию и плагинах.

Зачем писать тесты для вашего приложения на  Rails?
---------------------------------------------------

Rails предлагает писать тесты очень просто. Когда вы создаете свои модели и контроллеры, он начинает создавать скелет тестового кода.

Простой запуск тестов Rails позволяет убедиться, что ваш код придерживается нужной функциональности даже после большой переделки кода.

Тесты Rails также могут симулировать запросы браузера, таким образом, можно тестировать отклик своего приложения без необходимости тестирования с использованием браузера.

Введение в тестирование
-----------------------

Поддержка тестирования встроена в Rails с самого начала. И это не было так: "О! Давайте внесем поддержку запуска тестов, это ново и круто!" Почти каждое приложение на Rails сильно взаимодействует с базой данных, и, как результат, тестам также требуется база данных для работы. Чтобы писать эффективные тесты, следует понять, как настроить эту базу данных и наполнить ее образцом данных.

### Тестовая среда разработки

По умолчанию каждое приложение на Rails имеет три среды разработки: development, test и production. База данных для каждой из них настраивается в `config/database.yml`.

Отдельная тестовая база данных позволяет настраивать и работать с данными в изоляции. Тесты могут искажать тестовые данные с уверенностью, что они не затронут данные в базах данных development или production.

### Настройка Rails для тестирования с нуля

Rails создает папку `test` как только вы создаете проект Rails, используя `rails new _application_name_`. Если посмотрите список содержимого этой папки, то увидите:

```bash
$ ls -F test

fixtures/  functional/  integration/  performance/  test_helper.rb  unit/
```

Директория `unit` предназначена содержать тесты для ваших моделей, директория `functional` предназначена содержать тесты для ваших контроллеров, директория `integration` предназначена содержать тесты, которые включают любое взаимодействие контроллеров, и директория `performance` предназначена для тестов производительности.

Фикстуры это способ организации тестовых данных; они находятся в папке `fixtures`.

Файл `test_helper.rb` содержит конфигурацию по умолчанию для ваших тестов.

### Полная информация по фикстурам

Для хороших тестов необходимо подумать о настройке тестовых данных. В Rails этим можно управлять, определяя и настраивая фикстуры.

#### Что такое фикстуры?

_Fixtures_ это выдуманное слово для образцов данных. Фикстуры позволяют заполнить вашу тестовую базу данных предопределенными данными до запуска тестов. Фикстуры независимы от типа базы данных и написаны на YAML. На каждую модель имеется отдельный файл.

Фикстуры расположены в директории `test/fixtures`. Когда запускаете `rails generate model` для создания новой модели, незаконченные фикстуры будут автоматически созданы и помещены в эту директорию.

#### YAML

Фикстуры в формате YAML являются дружелюбным способом описать Ваш образец данных. Этот тип фикстур имеет расширение файла *.yml* (как в `users.yml`).

Вот образец файла фикстуры YAML:

```yaml
# lo & behold!  I am a YAML comment!
david:
 name: David Heinemeier Hansson
 birthday: 1979-10-15
 profession: Systems development

steve:
 name: Steve Ross Kellock
 birthday: 1974-09-27
 profession: guy with keyboard
```

Каждой фикстуре дается имя со следующим за ним списком с отступом пар ключ/значение, разделенных двоеточием. Записи обычно разделяются пустой строкой. Можете помещать комментарии в файл фикстуры, используя символ # в первом столбце. Ключи, представляющие ключевые слова YAML, такие как 'yes' или 'no', заключаются в кавычки, таким образом парсер YAML интерпретирует их корректно.

#### ERb

ERb позволяет встраивать код Ruby в шаблоны. Формат фикстур YAML предварительно обрабатывается с помощью ERb при загрузке фикстур. Это позволяет использовать Ruby для помощи в создании некоторых образцов данных. Например, следующий код создаст тысячу пользователей:

```erb
<% 1000.times do |n| %>
user_<%= n %>:
  username: <%= "user%03d" % n %>
  email: <%= "user%03d@example.com" % n %>
<% end %>
```

#### Фикстуры в действии

Rails по умолчанию автоматически загружает все фикстуры из папки "test/fixtures" для ваших юнит- и функциональных тестов. Загрузка состоит из трех этапов:

* Убираются любые существующие данные из таблицы, соответствующей фикстуре
* Загружаются данные фикстуры в таблицу
* Выгружаются данные фикстуры в переменную, в случае, если вы хотите обращаться к ним напрямую

#### Фикстуры это объекты Active Record

Фикстуры являются экземплярами Active Record. Как упоминалось в этапе №3 выше, Вы можете обращаться к объекту напрямую, поскольку он автоматически настраивается как локальная переменная для задачи тестирования. Например:

```ruby
# это возвратит объект User для фикстуры с именем david
users(:david)

# это возвратит свойство для david, названное id
users(:david).id

# он имеет доступ к методам, доступным для класса User
email(david.girlfriend.email, david.location_tonight)
```

Юнит-тестирование ваших моделей
-------------------------------

В Rails юнит-тесты это то, что вы пишете, чтобы протестировать свои модели.

Для этого руководства мы будем использовать _скаффолдинг_ Rails. Он создает модель, миграцию, контроллер и вьюхи для нового ресурса в одной операции. Он также создает полный набор для тестирования, следуя лучшей практике Rails. Мы будем использовать примеры из этого созданного кода и будем добавлять к нему дополнительные примеры по необходимости.

NOTE: Чтобы узнать больше о _скаффолдинге_ Rails, обратитесь к [Rails для начинающих](/getting-started-with-rails)

При использовании `rails generate scaffold` для ресурса, среди прочего, создается незаконченный тест в папке `test/models`:

```bash
$ rails generate scaffold post title:string body:text
...
create  app/models/post.rb
create  test/models/post_test.rb
create  test/fixtures/posts.yml
...
```

Незаконченный тест по умолчанию в `test/models/post_test.rb` выглядит так:

```ruby
require 'test_helper'

class PostTest < ActiveSupport::TestCase
  # Replace this with your real tests.
  test "the truth" do
    assert true
  end
end
```

Построчное изучение этого файла поможет вам ориентироваться в коде тестирования и терминологии Rails.

```ruby
require 'test_helper'
```

Как вы уже знаете, `test_helper.rb` определяет конфигурацию по умолчанию для запуска наших тестов. Эта строка включается во все тесты, таким образом все методы, добавленные в этот файл, доступны всем вашим тестам.

```ruby
class PostTest < ActiveSupport::TestCase
```

Класс `PostTest` определяет _тестовый случай (test case)_, поскольку он унаследован от `ActiveSupport::TestCase`. Поэтому `PostTest` имеет все методы, доступные в `ActiveSupport::TestCase`. Об этих методах вы узнаете немного позже.

Любой метод, определенный в тестовом случае `Test::Unit`, начинающийся с `test` (чувствительно к регистру), просто вызывает тест. Таким образом, `test_password`, `test_valid_password` и `testValidPassword` это правильные имена тестов, и запустятся автоматически при запуске тестового случая.

Rails добавляет метод `test`, который принимает имя теста и блок. Он создает обычный тест `Test::Unit` с именем метода, начинающегося с `test_`, поэтому:

```ruby
test "the truth" do
  assert true
end
```

Работает так же, как если бы написали:

```ruby
def test_the_truth
  assert true
end
```

Только макрос `test` делает имена тестов более читаемыми. Хотя можете использовать и обычные определения метода.

NOTE: Имя метода создается, заменяя пробелы на подчеркивания. Хотя результат не должен быть валидным идентификатором Ruby, имя может содержать знаки пунктуации и т.д. Это связано с тем, что в Ruby технически любая строка может быть именем метода. Необычность заключается в вызовах `define_method` и `send`, но формально ограничений нет.

```ruby
assert true
```

Эта строка кода называется _оператор контроля_. Оператор контроля это строка кода, которая вычисляет объект (или выражение) для ожидаемых результатов. Например, оператор контроля может проверить:

* является ли это значение = тому значению?
* является ли этот объект nil?
* вызывает ли эта строка кода исключение?
* является ли пароль пользователя больше, чем 5 символов?

Каждый тест содержит один или более операторов контроля. Только когда все операторы контроля успешны, тест проходит.

### Подготовка вашего приложения для тестирования

До того, как вы сможете запустить свои тесты, следует убедиться, что структура тестовой базы данных соответствует текущей. Для этого следует использовать такую команду rake:

```bash
$ rake db:migrate
...
$ rake db:test:load
```

Вышеупомянутая `rake db:migrate` запускает любые незагруженные миграции в среде _development_ и обновляет `db/schema.rb`. `rake db:test:load` пересоздает тестовую базу данных из текущего db/schema.rb. В следующий раз можете сначала запускать `db:test:prepare`, так как она сначала проверяет незагруженные миграции и надлежаще предупреждает вас.

NOTE: `db:test:prepare` провалится, если отсутствует db/schema.rb.

#### Задачи Rake для подготовки вашего приложения для тестирования

| Задачи                         | Описание                                                             |
| ------------------------------ | -------------------------------------------------------------------- |
| `rake db:test:clone`           | Пересоздает тестовую базу данных из схемы базы данных текущей среды |
| `rake db:test:clone_structure` | Пересоздает тестовую базу данных из структуры development            |
| `rake db:test:load`            | Пересоздает тестовую базу данных из текущего `schema.rb`             |
| `rake db:test:prepare`         | Проверяет незагруженные миграции и загружает тестовую схему          |
| `rake db:test:purge`           | Очищает тестовую базу данных.                                        |

TIP: Все эти команды rake и их описание можно увидеть, запустив `rake --tasks --describe`

### Запуск тестов

Запуск теста так же прост, как вызов файла, содержащего тестовый случай, с помощью Ruby:

```bash
$ ruby -Itest test/models/post_test.rb

Loaded suite models/post_test
Started
.
Finished in 0.023513 seconds.

1 tests, 1 assertions, 0 failures, 0 errors
```

Это запустит все тестовые методы в тестовом случае. Отметьте, что `test_helper.rb` находится в директории `test`, поэтому она должна быть добавлена в путь загрузки с использованием переключателя `-I`.

Также можете запустить определенный тестовый метод из тестового случая, используя переключатель `-n` с `именем тестового метода`.

```bash
$ ruby -Itest test/models/post_test.rb -n test_the_truth

Loaded suite models/post_test
Started
.
Finished in 0.023513 seconds.

1 tests, 1 assertions, 0 failures, 0 errors
```

Точка `.` обозначает прошедший тест. Когда тест проваливается, вы увидите `F`; когда тест вызывает ошибку, вы увидите `E` в этом месте. Последняя строка результата это итоги.

Чтобы увидеть, как сообщается при провале, давайте добавим проваливающийся тест в тестовом случае `post_test.rb`.

```ruby
test "should not save post without title" do
  post = Post.new
  assert !post.save
end
```

Давайте запустим только что добавленный тест.

```bash
$ ruby unit/post_test.rb -n test_should_not_save_post_without_title
Loaded suite -e
Started
F
Finished in 0.102072 seconds.

  1) Failure:
test_should_not_save_post_without_title(PostTest) [/test/models/post_test.rb:6]:
<false> is not true.

1 tests, 1 assertions, 1 failures, 0 errors
```

В результате `F` обозначает провал. Можете увидеть соответствующую трассировку под `1)` вместе с именем провалившегося теста. Следующие несколько строк содержат трассировку стека, затем сообщение, где упомянуто фактическое значение и ожидаемое оператором контроля значение. Сообщение оператора контроля об ошибке предоставляет достаточно информации, чтобы помочь выявить ошибку. Чтобы сделать сообщение о провале оператора контроля более читаемым, каждый оператор контроля предоставляет опциональный параметр сообщения, как показано тут:

```ruby
test "should not save post without title" do
  post = Post.new
  assert !post.save, "Saved the post without a title"
end
```

Запуск этого теста покажет более дружелюбное контрольное сообщение:

```bash
  1) Failure:
test_should_not_save_post_without_title(PostTest) [/test/models/post_test.rb:6]:
Saved the post without a title.
<false> is not true.
```

Теперь, чтобы этот тест прошел, можно добавить валидацию на уровне модели для поля _title_.

```ruby
class Post < ActiveRecord::Base
  validates :title, presence: true
end
```

Теперь тест пройдет. Давайте убедимся в этом, запустив его снова:

```bash
$ ruby unit/post_test.rb -n test_should_not_save_post_without_title
Loaded suite unit/post_test
Started
.
Finished in 0.193608 seconds.

1 tests, 1 assertions, 0 failures, 0 errors
```

Теперь вы увидели, что мы сначала написали тест, который не прошел для желаемой функциональности, затем мы написали некоторый код, добавляющий функциональность, и наконец мы убедились, что наш тест прошел. Этот подход к разработке программного обеспечения упоминается как _Разработка через тестирование, Test-Driven Development_ (TDD).

TIP: Многие разработчики на Rails практикуют _разработку через тестирование_ (TDD). Это отличный способ создать набор тестов, который использует каждую часть вашего приложения. TDD выходит за рамки этого руководства, если хотите им заниматься, можете начать с [15 TDD steps to create a Rails application](http://andrzejonsoftware.blogspot.com/2007/05/15-tdd-steps-to-create-rails.html).

Чтобы увидеть, как сообщается об ошибке, вот тест, содержащий ошибку:

```ruby
test "should report error" do
  # some_undefined_variable is not defined elsewhere in the test case
  some_undefined_variable
  assert true
end
```

Теперь вы увидите чуть больше результата в консоли от запуска тестов:

```bash
$ ruby unit/post_test.rb -n test_should_report_error
Loaded suite -e
Started
E
Finished in 0.082603 seconds.

  1) Error:
test_should_report_error(PostTest):
NameError: undefined local variable or method `some_undefined_variable' for #<PostTest:0x249d354>
    /test/models/post_test.rb:6:in `test_should_report_error'

1 tests, 0 assertions, 0 failures, 1 errors
```

Отметьте 'E' в результате. Она отмечает тест с ошибкой.

NOTE: Запуск каждого тестового метода останавливается как только случается любая ошибка или провал оператора контроля, и набор тестов продолжается со следующего метода. Все тестовые методы запускаются в алфавитном порядке.

### Что включить в ваши юнит-тесты

В идеале хотелось бы включить тест для всего, что может возможно сломаться. Хорошая практика иметь как минимум один тест на каждую валидацию и как минимум один тест на каждый метод в модели.

### Доступные операторы контроля

К этому моменту вы уже увидели некоторые из имеющихся операторов контроля. Операторы контроля это рабочие лошадки тестирования. Они единственные, кто фактически выполняет проверки, чтобы убедиться, что все работает как задумано.

Имеется множество различных типов операторов контроля, которые вы можете использовать. Вот полный перечень операторов контроля, которые поставляются с `test/unit`, библиотекой тестирования, используемой Rails. Параметр `[msg]` это опциональное строковое сообщение, которое можно определить, чтобы сделать сообщение о провале вашего теста яснее. Он не обязательный.

| Оператор контроля                                                | Назначение                                                                       |
| ---------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| `assert( boolean, [msg] )`                                       | Обеспечивает, что объект/выражение равен true.                                   |
| `assert_equal( expected, actual, [msg] )`                        | Обеспечивает, что `expected == actual` равно true.                               |
| `assert_not_equal( expected, actual, [msg] )`                    | Обеспечивает, что `expected == actual` равно false.                              |
| `assert_same( expected, actual, [msg] )`                         | Обеспечивает, что `expected.equal?(actual)` равно true.                          |
| `assert_not_same( expected, actual, [msg] )`                     | Обеспечивает, что `expected.equal?(actual)` равно false.                         |
| `assert_nil( obj, [msg] )`                                       | Обеспечивает, что `obj.nil?` равно true.                                         |
| `assert_not_nil( obj, [msg] )`                                   | Обеспечивает, что `!obj.nil?` равно true.                                        |
| `assert_match( regexp, string, [msg] )`                          | Обеспечивает, что строка соответствует регулярному выражению.                    |
| `assert_no_match( regexp, string, [msg] )`                       | Обеспечивает, что строка не соответствует регулярному выражению.                 |
| `assert_in_delta( expecting, actual, delta, [msg] )`             | Обеспечивает, что числа `expecting` и `actual` в пределах `delta` друг от друга. |
| `assert_throws( symbol, [msg] ) { block }`                       | Обеспечивает, что данный блок возвращает symbol.                                 |
| `assert_raise( exception1, exception2, ... ) { block }`          | Обеспечивает, что данный блок вызывает одно из данных исключений.                |
| `assert_nothing_raised( exception1, exception2, ... ) { block }` | Обеспечивает, что данный блок не вызывает одно из данных исключений.             |
| `assert_instance_of( class, obj, [msg] )`                        | Обеспечивает, что `obj` типа `class`.                                            |
| `assert_kind_of( class, obj, [msg] )`                            | Обеспечивает, что `obj` является или наследуется от `class`.                     |
| `assert_respond_to( obj, symbol, [msg] )`                        | Обеспечивает, что `obj` имеет метод, названный `symbol`.                         |
| `assert_operator( obj1, operator, obj2, [msg] )`                 | Обеспечивает, что `obj1.operator(obj2)` равен true.                              |
| `assert_send( array, [msg] )`                                    | Обеспечивает, что запуск метода, расположенного в `array[1]` на объекте в `array[0]` с параметрами `array[2 и выше]` равен true. Этот метод странный, ага?|
| `flunk( [msg] )`                                                 | Обеспечивает провал. Это полезно для явной отметки незаконченных пока тестов.    |

В силу модульной природы фреймворка тестирования, возможно создать свои собственные операторы контроля. Фактически Rails так и делает. Он включает некоторые специализированные операторы контроля, чтобы сделать жизнь разработчика проще.

NOTE: Создание собственных операторов контроля это особый разговор, которого мы касаться не будем.

### Специфичные операторы контроля Rails

Rails добавляет некоторые свои операторы контроля в фреймворк `test/unit`:

| Оператор контроля                                                                 | Назначение |
| --------------------------------------------------------------------------------- | ---------- |
| `assert_difference(expressions, difference = 1, message = nil) {...}`             |Тестирует числовую разницу между возвращаемым значением expression и результатом вычисления в данном блоке.|
| `assert_no_difference(expressions, message = nil, &amp;block)`                    |Обеспечивает, что числовой результат вычисления expression не изменяется до и после применения переданного в блоке.|
| `assert_recognizes(expected_options, path, extras={}, message=nil)`               |Обеспечивает, что роутинг данного path был правильно обработан, и что проанализированные опции (заданные в хэше expected_options) соответствуют path. По существу он утверждает, что Rails распознает маршрут, заданный в expected_options.|
| `assert_generates(expected_path, options, defaults={}, extras = {}, message=nil)` |Утверждает, что предоставленные options могут быть использованы для создания предоставленного пути. Это противоположность assert_recognizes. Параметр extras используется, чтобы сообщить запросу имена и значения дополнительных параметров запроса, которые могут быть в строке запроса. Параметр message позволяет определить свое сообщение об ошибке при провале оператора контроля.|
| `assert_response(type, message = nil)`                                            |Утверждает, что отклик идет с определенным кодом статуса. Можете определить `:success` для обозначения 200-299, `:redirect` для обозначения 300-399, `:missing` для обозначения 404, или `:error` для соответствия диапазону 500-599|
| `assert_redirected_to(options = {}, message=nil)`                                 |Утверждает, что опции перенаправления передаются в соответствии с вызовами перенаправления в последнем экшне. Это соответствие может быть частичным, так `assert_redirected_to(controller: "weblog")` будет также соответствовать перенаправлению `redirect_to(controller: "weblog", action: "show")` и тому подобное.|
| `assert_template(expected = nil, message=nil)`                                    |Утверждает, что запрос был ренедерен с подходящим файлом шаблона.|

Вы увидите использование некоторых из этих операторов контроля в следующей части.

Функциональные тесты для ваших контроллеров
-------------------------------------------

В Rails тестирование различных экшнов одного контроллера называется написанием функциональных тестов для этого контроллера. Контроллеры обрабатывают входящие веб запросы к вашему приложению и в конечном итоге откликаются отрендеренной вьюхой.

### Что включать в функциональные тесты

Следует протестировать такие вещи, как:

* был ли веб запрос успешным?
* был ли пользователь перенаправлен на правильную страницу?
* был ли пользователь успешно аутентифицирован?
* был ли правильный объект сохранен в шаблон отклика?
* было ли подходящее сообщение отражено для пользователя во вьюхе

Теперь, когда мы использовали Rails scaffold generator для нашего ресурса `Post`, он также создал код контроллера и тесты. Можете посмотреть файл `posts_controller_test.rb` в директории `test/controllers`.

Давайте пробежимся про одному такому тесту, `test_should_get_index` из файла `posts_controller_test.rb`.

```ruby
test "should get index" do
  get :index
  assert_response :success
  assert_not_nil assigns(:posts)
end
```

В тесте `test_should_get_index`, Rails имитирует запрос к экшну index, убеждается, что запрос был успешным, а также обеспечивает, что назначается валидная переменная экземпляра `posts`.

Метод `get` стартует веб запрос и заполняет результаты в ответ. Он принимает 4 аргумента:

* Экшн контроллера, к которомы обращаетесь. Он может быть в форме строки или символа.
* Необязательный хэш параметров запроса для передачи в экшн (эквивалент параметров строки запроса или переменных post).
* Необязательный хэш переменных сессии для передачи вместе с запросом.
* Необязательный хэш значений flash.

Пример: Вызов экшна `:show`, передача `id`, равного 12, как `params`, и установка `user_id` как 5 в сессии:

```ruby
get(:show, {'id' => "12"}, {'user_id' => 5})
```

Другой пример: Вызов экшна `:view`, передача `id`, равного 12, как `params`, в этот раз без сессии, но с сообщением flash.

```ruby
get(:view, {'id' => '12'}, nil, {'message' => 'booya!'})
```

NOTE: Если попытаетесь запустить тест `test_should_create_post` из `posts_controller_test.rb`, он провалится из-за недавно добавленной валидации на уровне модели, и это правильно.

Давайте изменим тест `test_should_create_post` в `posts_controller_test.rb` так, чтобы все наши тесты проходили:

```ruby
test "should create post" do
  assert_difference('Post.count') do
    post :create, post: {title: 'Some title'}
  end

  assert_redirected_to post_path(assigns(:post))
end
```

Теперь можете попробовать запустить все тесты, и они должны пройти.

### Доступные типы запросов для функциональных тестов

Если вы знакомы с протоколом HTTP, то знаете, что `get` это тип запроса. Имеется 6 типов запроса, поддерживаемых в функциональных тестах Rails:

* `get`
* `post`
* `patch`
* `put`
* `head`
* `delete`

Все типы запросов являются методами, которые можете использовать, однако, скорее всего, первые два вы будете использовать чаше остальных.

### The Four Hashes of the Apocalypse

После того, как запрос был сделан с использованием одного из 5 методов (`get`, `post`, и т.д.) и обработан, у Вас будет 4 объекта Hash, готовых для использования:

* `assigns` - Любые объекты, хранящиеся как переменные экземпляров в экшнах для использования во вьюхах.
* `cookies` - Любые установленные куки.
* `flash` - Любые объекты, находящиеся во flash.
* `session` - Любой объект, находящийся в переменных сессии.

Как и в случае с обычными объектами Hash, можете получать доступ к значениям, указав ключ в строке. Также можете указать его именем символа, кроме `assigns`. Например:

```ruby
flash["gordon"]               flash[:gordon]
session["shmession"]          session[:shmession]
cookies["are_good_for_u"]     cookies[:are_good_for_u]

# Так как нельзя использовать assigns[:something] в силу исторических причин:
assigns["something"]          assigns(:something)
```

### Доступные переменные экземпляра

В Ваших функциональных тестах также доступны три переменные экземпляра:

* `@controller` - Контроллер, обрабатывающий запрос
* `@request` - Запрос
* `@response` - Отклик

### Тестирование шаблонов и макетов

Если хотите убедиться, что отклик рендерит правильные шаблон и макет, можно использовать метод `assert_template`:

```ruby
test "index should render correct template and layout" do
  get :index
  assert_template :index
  assert_template layout: "layouts/application"
end
```

Отметьте, что нельзя тестировать шаблон и макет одновременно, в одном вызове метода `assert_template`. Также для тестирования `layout` можно задать регулярное выражение вместо строки, но использование строки более точно описывает ситуацию. С другой стороны, следует включать имя директории "layouts" даже когда файл макета находится в этой стандартной директории для макетов. Следовательно,

```ruby
assert_template layout: "application"
```

не будет работать.

Если вьюха рендерит какой-либо партиал, при тестировании макета вы должны указать партиал в то же время. Иначе оператор контроля провалится.

Следовательно:

```ruby
test "new should render correct layout" do
  get :new
  assert_template layout: "layouts/application", partial: "_form"
end
```

является правильным способом убедиться в правильности макета, когда вьюха рендерит партиал с именем `_form`. Если опустить ключ `:partial` в вызове `assert_template` он будет ругаться.

### Полноценный пример функционального теста

Вот другой пример, использующий `flash`, `assert_redirected_to` и `assert_difference`:

```ruby
test "should create post" do
  assert_difference('Post.count') do
    post :create, post: {title: 'Hi', body: 'This is my first post.'}
  end
  assert_redirected_to post_path(assigns(:post))
  assert_equal 'Post was successfully created.', flash[:notice]
end
```

### Тестирование вьюх

Тестирование отклика на ваш запрос с помощью подтверждения наличия ключевых элементов HTML и их содержимого, это хороший способ протестировать вьюхи вашего приложения. Оператор контроля `assert_select` позволяет осуществить это с помощью простого, но мощного синтаксиса.

NOTE: В другой документации вы можете обнаружить применение `assert_tag`, но сейчас он устарел в пользу `assert_select`.

Имеется две формы `assert_select`:

`assert_select(selector, [equality], [message])` обеспечивает, что условие equality выполняется для выбранных через selector элементах. selector может быть выражением селектора CSS (String), выражением с заменяемыми значениями или объектом `HTML::Selector`.

`assert_select(element, selector, [equality], [message])` обеспечивает, что условие equality выполняется для всех элементов, выбранных через selector начиная с _element_ (экземпляра `HTML::Node`) и его потомков.

Например, можете проверить содержимое в элементе title Вашего отклика с помощью:

```ruby
assert_select 'title', "Welcome to Rails Testing Guide"
```

Также можно использовать вложенные блоки `assert_select`. В этом случае внутренний `assert_select` запускает оператор контроля для полной коллекции элементов, выбранных во внешнем блоке `assert_select`:

```ruby
assert_select 'ul.navigation' do
  assert_select 'li.menu_item'
end
```

Альтернативно, коллекция элементов, переданная внешним `assert_select`, может быть перебрана, таким образом `assert_select` может быть вызван отдельно для каждого элемента. Предположим для примера, что отклик содержит два упорядоченных списка, каждый из четырех элементов, тогда оба следующих теста пройдут.

```ruby
assert_select "ol" do |elements|
  elements.each do |element|
    assert_select element, "li", 4
  end
end

assert_select "ol" do
  assert_select "li", 8
end
```

Оператор контроля `assert_select` достаточно мощный. Для более продвинутого использования обратитесь к его [документации](http://api.rubyonrails.org/classes/ActionController/Assertions/SelectorAssertions.html).

#### Дополнительные операторы контроля, основанные на вьюхе

В тестировании вьюх в основном используется такие операторы контроля:

| Оператор контроля                                          | Назначение                                              |
| ---------------------------------------------------------- | ------------------------------------------------------- |
| `assert_select_email`                                      | Позволяет сделать утверждение относительно тела e-mail. |
| `assert_select_encoded`                                    | Позволяет сделать утверждение относительно закодированного HTML. Он делает это декодируя содержимое каждого элемента и затем вызывая блок со всеми декодированными элементами. |
| `css_select(selector)` или `css_select(element, selector)` | Возвращают массив всех элементов, выбранных через _selector_. Во втором варианте сначала проверяется соответствие базовому _element_, а затем пытается применить соответствие выражению _selector_ на каждом из его детей. Если нет соответствий, оба варианта возвращают пустой массив. |

Вот пример использования `assert_select_email`:

```ruby
assert_select_email do
  assert_select 'small', 'Please click the "Unsubscribe" link if you want to opt-out.'
end
```

Интеграционное тестирование
---------------------------

Интеграционные тесты используются для тестирования взаимодействия любого числа контроллеров. Они в основном используются для тестирования важных рабочих процессов в вашем приложении.

В отличие от юнит- и функциональных тестов, интеграционные тесты должны быть явно созданы в папке 'test/integration' вашего приложения. Rails предоставляет вам генератор для создания скелета интеграционного теста.

```bash
$ rails generate integration_test user_flows
      exists  test/integration/
      create  test/integration/user_flows_test.rb
```

Вот как выглядит вновь созданный интеграционный тест:

```ruby
require 'test_helper'

class UserFlowsTest < ActionDispatch::IntegrationTest
  fixtures :all

  # Replace this with your real tests.
  test "the truth" do
    assert true
  end
end
```

Интеграционные тесты унаследованы от `ActionController::IntegrationTest`. Это делает доступным несколько дополнительных хелперов для использования в ваших интеграционных тестах. Также необходимо явно включать фикстуры, чтобы сделать их доступными для теста.

### Хелперы, доступные для интеграционных тестов

В дополнение к стандартным хелперам тестирования, есть несколько дополнительных хелперов, доступных для интеграционных тестов:

| Хелпер                                                             | Назначение                                                                         |
| ------------------------------------------------------------------ | ---------------------------------------------------------------------------------- |
| `https?`                                                           | Возвращает `true`, если сессия имитирует безопасный запрос HTTPS.                  |
| `https!`                                                           | Позволяет имитировать безопасный запрос HTTPS.                                     |
| `host!`                                                            | Позволяет установить имя хоста для использовании в следующем запросе.              |
| `redirect?`                                                        | Возвращает `true`, если последний запрос был перенаправлением.                     |
| `follow_redirect!`                                                 | Отслеживает одиночный перенаправляющий отклик.                                     |
| `request_via_redirect(http_method, path, [parameters], [headers])` | Позволяет сделать HTTP запрос и отследить любые последующие перенаправления.       |
| `post_via_redirect(path, [parameters], [headers])`                 | Позволяет сделать HTTP запрос POST и отследить любые последующие перенаправления.  |
| `get_via_redirect(path, [parameters], [headers])`                  | Позволяет сделать HTTP запрос GET и отследить любые последующие перенаправления.   |
| `patch_via_redirect(path, [parameters], [headers])`                | Позволяет сделать HTTP запрос PATCH и отследить любые последующие перенаправления. |
| `put_via_redirect(path, [parameters], [headers])`                  | Позволяет сделать HTTP запрос PUT и отследить любые последующие перенаправления.   |
| `delete_via_redirect(path, [parameters], [headers])`               | Позволяет сделать HTTP запрос DELETE и отследить любые последующие перенаправления.|
| `open_session`                                                     | Открывает экземпляр новой сессии.                                                  |

### Примеры интеграционного тестирования

Простой интеграционный тест, использующий несколько контроллеров:

```ruby
require 'test_helper'

class UserFlowsTest < ActionDispatch::IntegrationTest
  fixtures :users

  test "login and browse site" do
    # login via https
    https!
    get "/login"
    assert_response :success

    post_via_redirect "/login", username: users(:avs).username, password: users(:avs).password
    assert_equal '/welcome', path
    assert_equal 'Welcome avs!', flash[:notice]

    https!(false)
    get "/posts/all"
    assert_response :success
    assert assigns(:products)
  end
end
```

Как видите, интеграционный тест вовлекает несколько контроллеров и использует весь стек от базы данных до отправителя. В дополнение можете иметь несколько экземпляров сессии, открытых одновременно в тесте, и расширить эти экземпляры с помощью методов контроля для создания очень мощного тестирующего DSL (Предметно-ориентированного языка программирования) только для вашего приложения.

Вот пример нескольких сессий и собственного DSL в общем тесте

```ruby
require 'test_helper'

class UserFlowsTest < ActionDispatch::IntegrationTest
  fixtures :users

  test "login and browse site" do

    # User avs logs in
    avs = login(:avs)
    # User guest logs in
    guest = login(:guest)

    # Both are now available in different sessions
    assert_equal 'Welcome avs!', avs.flash[:notice]
    assert_equal 'Welcome guest!', guest.flash[:notice]

    # User avs can browse site
    avs.browses_site
    # User guest can browse site as well
    guest.browses_site

    # Continue with other assertions
  end

  private

  module CustomDsl
    def browses_site
      get "/products/all"
      assert_response :success
      assert assigns(:products)
    end
  end

  def login(user)
    open_session do |sess|
      sess.extend(CustomDsl)
      u = users(user)
      sess.https!
      sess.post "/login", username: u.username, password: u.password
      assert_equal '/welcome', path
      sess.https!(false)
    end
  end
end
```

Задачи Rake для запуска тестов
------------------------------

Не нужно настраивать и запускать ваши тесты вручную один за другим. Rails поставляется с несколькими задачами rake, помогающими в тестировании. Нижеследующая таблица перечисляет все задачи rake, которые идут в дефолтном Rakefile при создании нового проекта Rail.

| Задачи                  | Описание                                                                                                     |
| ----------------------- | ------------------------------------------------------------------------------------------------------------ |
| `rake test`             | Запускает все юнит-, функциональные и объединенные тесты. Также можете просто запустить `rake`, так как задание _test_ идет по умолчанию.|
| `rake test:benchmark`   | Запускает тесты производительности в режиме бенчмаркинга                                                     |
| `rake test:controllers` | Запускает все тесты контроллеров из `test/controllers`                                                       |
| `rake test:functionals` | Запускает все функциональные тесты из `test/controllers`, `test/mailers` и `test/functional`                 |
| `rake test:helpers`     | Запускает все тесты хелперов из `test/helpers`                                                               |
| `rake test:integration` | Запускает все объединенные тесты из `test/integration`                                                       |
| `rake test:mailers`     | Запускает все тесты рассыльщиков из `test/mailers`                                                           |
| `rake test:models`      | Запускает все тесты моделей из `test/models`                                                                 |
| `rake test:profile`     | Запускает тесты производительности в режиме профилирования                                                   |
| `rake test:recent`      | Тестирует последние изменения                                                                                |
| `rake test:uncommitted` | Выполняет все тесты, которые не отправлены в систему контроля версии. Поддерживается только Git и Subversion |
| `rake test:units`       | Запускает все юнит-тесты из `test/models`, `test/helpers` и `test/unit`                                      |

Краткая заметка о Test::Unit
----------------------------

Ruby поставляется с полным набором библиотек. Одним небольшим гемом-библиотекой является `Test::Unit`, фреймворк для юнит-тестирования в Ruby. Все основные операторы контроля, обсуждаемые ранее, фактически определены в `Test::Unit::Assertions`. Класс `ActiveSupport::TestCase`, который мы используем в наших юнит и функциональных тестах, расширяет `ActiveSupport::TestCase`, позволяя нам использовать все основные операторы контроля в наших тестах.

NOTE: Подробности по `Test::Unit` смотрите в [документации по test/unit](http://ruby-doc.org/stdlib/libdoc/test/unit/rdoc/)

Setup и Teardown
----------------

Если хотите запустить блок кода до старта каждого теста и другой блок кода после окончания каждого теста, у Вас есть два специальных колбэка для этой цели. Давайте рассмотрим это на примере нашего функционального теста для контроллера `Posts`:

```ruby
require 'test_helper'

class PostsControllerTest < ActionController::TestCase

  # вызывается перед каждым отдельным тестом
  def setup
    @post = posts(:one)
  end

  # вызывается после каждого отдельного теста
  def teardown
    # так как мы пересоздаем @post перед каждым тестом,
    # установка его в nil тут не обязательна, но, я надеюсь,
    # Вы поняли, как использовать метод teardown
    @post = nil
  end

  test "should show post" do
    get :show, id: @post.id
    assert_response :success
  end

  test "should destroy post" do
    assert_difference('Post.count', -1) do
      delete :destroy, id: @post.id
    end

    assert_redirected_to posts_path
  end

end
```

В вышеприведенном, метод `setup` вызывается перед каждым тестом, таким образом `@post` доступна каждому из тестов. Rails выполняет `setup` и `teardown` как ActiveSupport::Callbacks. Что по существу означает, что можно использовать `setup` и `teardown` не только как методы в своих тестах. Можете определить их, используя:

* блок
* метод (как в вышеприведенном примере)
* имя метода как символ
* lambda

Давайте рассмотрим предыдущий пример, определив колбэк `setup` указав имя метода как символ:

```ruby
require 'test_helper'

class PostsControllerTest < ActionController::TestCase

  # called before every single test
  setup :initialize_post

  # called after every single test
  def teardown
    @post = nil
  end

  test "should show post" do
    get :show, id: @post.id
    assert_response :success
  end

  test "should update post" do
    patch :update, id: @post.id, post: {}
    assert_redirected_to post_path(assigns(:post))
  end

  test "should destroy post" do
    assert_difference('Post.count', -1) do
      delete :destroy, id: @post.id
    end

    assert_redirected_to posts_path
  end

  private

  def initialize_post
    @post = posts(:one)
  end

end
```

Тестирование маршрутов
----------------------

Как и все в вашем приложении на Rails, рекомендуется тестировать маршруты. Пример теста для маршрутов в экшне по умолчанию `show` для контроллера `Posts`, приведенного ранее, будет выглядеть так:

```ruby
test "should route to post" do
  assert_routing '/posts/1', {controller: "posts", action: "show", id: "1"}
end
```

Тестирование почтовых рассыльщиков
----------------------------------

Тестирование классов рассыльщика требует несколько специфичных инструментов для тщательной работы.

### Держим почтовик под контролем

Ваши классы рассыльщика - как и любая другая часть вашего приложения на Rails - должны быть протестированы, что они работают так, как ожидается.

Тестировать классы рассыльщика нужно, чтобы быть уверенным в том, что:

* электронные письма обрабатываются (создаются и отсылаются)
* содержимое email правильное (тема, получатель, тело и т.д.)
* правильные письма отправляются в нужный момент

#### Со всех сторон

Есть два момента в тестировании рассыльщика, юнит-тесты и функциональные тесты. В юнит-тестах обособленно запускается рассыльщик с жестко заданными входящими значениями, и сравнивается результат с известным значением (фикстуры). В функциональных тестах не нужно тестировать мелкие детали, вместо этого мы тестируем, что наши контроллеры и модели правильно используют рассыльщик. Мы тестируем, чтобы подтвердить, что правильный email был послан в правильный момент.

### Юнит-тестирование

Для того, чтобы протестировать, что ваш рассыльщик работает как надо, можете использовать юнит-тесты для сравнения фактических результатов рассыльщика с предварительно написанными примерами того, что должно быть получено.

#### Реванш фикстур

Для целей юнит-тестирования рассыльщика фикстуры используются для предоставления примера, как результат _должен_ выглядеть. Так как это примеры электронных писем, а не данные Active Record, как в других фикстурах, они должны храниться в своей поддиректории отдельно от других фикстур. Имя директории в `test/fixtures` полностью соответствует имени рассыльщика. Таким образом, для рассыльщика с именем `UserMailer` фикстуры должны располагаться в директории `test/fixtures/user_mailer`.

При создании своего рассыльщика генератор создает незавершенные фикстуры для каждого из экшнов рассыльщиков. Если вы не используете генератор, следует создать эти файлы самостоятельно.

#### Простой тестовый случай

Вот юнит-тест для тестирования рассыльщика с именем `UserMailer`, экшн `invite` которого используется для рассылки приглашений друзьям. Это адаптированная версия исходного теста, созданного генераторм для экшна `invite`.

```ruby
require 'test_helper'

class UserMailerTest < ActionMailer::TestCase
  tests UserMailer
  test "invite" do
    @expected.from    = 'me@example.com'
    @expected.to      = 'friend@example.com'
    @expected.subject = "You have been invited by #{@expected.from}"
    @expected.body    = read_fixture('invite')
    @expected.date    = Time.now

    assert_equal @expected.encoded, UserMailer.create_invite('me@example.com', 'friend@example.com', @expected.date).encoded
  end

end
```

В этом тесте `@expected` является экземпляром `TMail::Mail`, которую можете использовать в своих тестах. Она определена в `ActionMailer::TestCase`. Вышеприведенный тест использует `@expected` для создания email, который он потом сверяет с email, созданным рассыльщиком. Фикстура `invite` это тело email и она используется как пример содержимого с которым будет сверка. Хелпер `read_fixture` используется для считывания содержимого из этого файла.

Вот содержимое фикстуры `invite`:

```
Hi friend@example.com,

You have been invited.

Cheers!
```

Сейчас самое время понять немного больше о написании тестов для ваших рассыльщиков. Строка `ActionMailer::Base.delivery_method = :test` в `config/environments/test.rb` устанавливает метод доставки в тестовом режиме, таким образом, email не будет фактически доставлен (полезно во избежание спама для Ваших пользователей во время тестирования), но вместо этого он будет присоединен к массиву (`ActionMailer::Base.deliveries`).

Однако часто в юнит-тестах почта на самом деле не будет отправлена, а просто создана, как в вышеприведенном примере, где определенное содержимое email сверяется с тем, какое оно должно быть.

### Функциональное тестирование

Функциональное тестирование рассыльщиков предполагает не только проверку того, что тело email, получатели и так далее корректны. В функциональных тестах писем мы вызываем методы доставки почты и проверяем, что надлежащие электронные письма присоединяются в перечень доставки. Это позволяет с большой долей уверенности предположить, что методы доставки работают. Возможно, вам будет более интересным, отправляет ли ваша бизнес логика электронные письма тогда, когда это от нее ожидается. Например, можете проверить, что операция по приглашению друзей надлежаще рассылает письма:

```ruby
require 'test_helper'

class UserControllerTest < ActionController::TestCase
  test "invite friend" do
    assert_difference 'ActionMailer::Base.deliveries.size', `1 do
      post :invite_friend, email: 'friend@example.com'
    end
    invite_email = ActionMailer::Base.deliveries.last

    assert_equal "You have been invited by me@example.com", invite_email.subject
    assert_equal 'friend@example.com', invite_email.to[0]
    assert_match(/Hi friend@example.com/, invite_email.body)
  end
end
```

Другие подходы к тестированию
-----------------------------

Тестирование, основанное на встренном `test/unit`, не является единственным способом тестировать приложение на Rails. Разработчики на Rails прибегают к различным подходам и вспомогательным инструментам для тестирования, включающим:

* [NullDB](http://avdi.org/projects/nulldb/), способ ускорить тестирование, избегая использование базы данных.
* [Factory Girl](https://github.com/thoughtbot/factory_girl/tree/master), замена для фикстур.
* [Machinist](https://github.com/notahat/machinist/tree/master), другая замена для фикстур.
* [Shoulda](http://www.thoughtbot.com/projects/shoulda), расширение для `test/unit` с дополнительными хелперами, макросами и операторами контроля.
* [RSpec](http://relishapp.com/rspec), фреймворк разработки, основанной на поведении

